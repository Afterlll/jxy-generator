# 江喜原 - 定制化代码生成项目

> 该项目目前处于开发阶段 🐣，项目会持续开发完善，感谢大家的关注支持！

## 项目介绍

这是一个非常有趣又实用的项目，基于 React + Spring Boot + Vert.x 响应式编程的 **定制化代码生成项目** 。



注意！这次的项目会很特别，听起来是一个项目，但其实是循序渐进的 **3 个项目** ！



完整项目分为 3 个阶段：

1）第一阶段，制作属于自己的 `本地代码生成器` ，是一个 **基于命令行的脚手架** ，能够根据用户的交互式输入快速生成特定代码。





2）第二阶段，让我们上升一个层次，我们开发 `制作代码生成器的工具` 。比如你有一段常用的项目代码，使用该工具，可以快速把项目代码制作为代码生成器，将是提高工作效率的大杀器！



3）第三阶段，让我们再上升一个层次，开发 `在线代码生成器平台` ！你可以在平台上制作发布自己的代码生成器，还可以在线使用别人的代码生成器，甚至可以共享协作！


![img_1.png](img%2Fimg_1.png)


### 学习意义

1）教程资料少：网上虽然有现成的项目模板，但基本都是别人封装好的，只能按作者的要求生成，并且缺少项目教程；而本项目不仅带大家做自己的代码生成器，还会 **进 2 步** 扩展，打造制作自定义代码生成器的工具和平台。

2）新颖且亮眼：别人写代码，而你做生产代码的脚手架、工具和平台来提高研发效能，降维打击。

3）能学到东西：不再是增删改查的项目，而是包含了大量的实际业务场景、系统设计和解决方案。

4）有区分度：区别于传统 Web 应用，项目涉及命令行应用、响应式编程、性能优化的入门及实战，给你的简历增加竞争力。



### 解决的问题

1）代码生成器本身的作用就是自动生成常见、重复性的代码片段，**解决重复编码、效率低下的问题** 。

2）虽然网上有很多代码生成器，但都是别人制作封装好的，很多时候还是 **无法满足实际开发的定制化需求** （比如要在每个类上增加特定的注解和注释）。这也是为什么明明有代码生成器，很多开发者还是会抱怨自己的工作总是复制粘贴、编写重复的代码、天天 CRUD（增删改查）。如果能够有一个工具帮助开发者快速定制属于自己的代码生成器，那么将进一步提高开发效率。

3）在团队开发中，要生成的代码可能是需要频繁变化和持续更新维护的。如果有一个线上平台来维护多个不同的代码生成器，支持在线编辑和共享生成器，在提高开发效率的同时、将有利于协作共建，打造更高质量的代码生成器。



### 实际应用

举例一些代码生成的实际应用场景，我们将通过本项目进行解决：

1）经常做算法题目的同学，可能需要一套 Java ACM 代码输入模板，能够支持多种不同输入模式（比如单次读取和循环）。

2）经常开发新项目的同学，可能需要一套初始化项目模板代码，比如一键生成 Controller 层代码（替换其中的对象）、整合 Redis 和 MySQL 依赖等。

3）甚至可以制作项目 “换皮” 工具，支持一键给网络热门项目换皮（比如替换项目的名称、Logo 等）



## 技术选型

暂定的核心技术如下，实际开发中还会引入新技术



### 前端

- React 开发框架 + 组件库 + 代码编辑器
- 前端工程化：ESLint + Prettier + TypeScript



### 后端

- Java Spring Boot + MySQL + MyBatis Plus（万用后端模板）
- Java 命令行应用开发
- FreeMarker 模板引擎
- Vert.x 响应式编程
- Caffeine + Redis 多级缓存
- 分布式任务调度系统
- 多种设计模式
- 多种系统设计的巧思
- 对象存储

## 项目设计

### 第一阶段

#### java原生方式实现

基于 ACM TEMPLATE 实现java原生方式代码生成器

##### 静态代码生成器实现

此处的静态文件，是我们根据需求下的一个定义，指生成时可以直接复制、不做任何改动的文件。


- 使用现有的工具库复制目录
  
    > hutool官方文档：[https://www.hutool.cn/]()

  这种方式的优点显而易见，非常简单，但缺点就是不够灵活，只能整个目录生成，如果想忽略目录中的某个文件，就得生成后再删除，浪费性能。



- 递归遍历

  如果自己实现递归遍历，就可以很轻松地得到目录的完整结构树信息，可以由此制作出文件对比工具、目录分析工具、目录总结工具等等
    



##### 动态代码生成器实现


实现了静态文件生成(复制目录)后，接下来让我们思考下如何对某个基础文件进行定制，根据用户的输入参数动态生成文件
明确动态生成需求
- 对于 ACM 示例模板项目，我们可以怎么定制生成呢?
让我们先明确几个动态生成的需求:
  1. 在代码开头增加作者 @Author 注释(增加代码
  2. 修改程序输出的信息提示(替换代码)
  3. 将循环读取输入改为单次读取 (可选代码)


> 使用模板引擎解决 [https://freemarker.apache.org/docs/index.html]()




##### 静态 + 动态代码生成器实现

现有工具 + 模板引擎 




#### java命令行实现


##### 需要使用命令行的原因

之前我们实现的基于java的方式，对应用户来说是很不友好的，对于使用我们项目的用户来说，不仅需要下载我们的源码，还需要安装java环境，这是十分致命的。基于此原因，开发命令行版本应运而生。


##### 什么是命令行程序？
- 命令行程序俗称 CLI(Command Line Interface) ，是指通过命令行界面运行的应用程序。通过终端窗口接收用户输入的 **纯文本** 命令，并执行相应的任务
- 一些常见的命令行环境包括 Unix/Linux 的终端、Windows 的命令提示符和 PowerShel等。学编程的同学可能没有开发过命令行程序，但一定都接触过终端!




##### 命令的结构
一图胜千言，输入给命令行的命令通常包含
- command: 命令类型，具体要做的事。
- option: 选项，用于改变命令的行为。
- parameter: 参数，传递给命令行工具的值。

![img.png](img%2Fimg.png)

##### 为什么要开发命令行?
命令行程序的几个优点:
- 不依赖于特定的图形界面，非常轻量
- 通常可以直接在操作系统自带的终端环境中运行
- 可以和用户交互、给用户输入引导和帮助手册
- 内置一些快捷操作(比如查看历史命令、上下切换命令)

还有一个最大的优点 —— 简单直接，比如复制粘贴别人写好的命令就能执行，而不用像使用网页一样点击多次，非常符合程序员的使用 (偷懒)习惯，less is more!


##### 解决方案

这里我们使用 **Picocli** 实现命令行模式的开发。
- github文档   [https://github.com/remkop/picocli]()
- 官方文档      [https://picocli.info/]()
- 中文教程      [https://blog.csdn.net/it_freshman/article/details/125458116]()


##### Picocli 命今行代码生成器开发

首先明确我们的需求，这个命令行程序需要支持 3 种子命令

- **generate** 子命令
  - 生成文件
- **list** 子命令
  - 查看要生成的原始文件列表信息
- **config** 子命令
  - 查看允许用户传入的动态参数信息



##### 命名行的使用方式

- jar包构建
  - java jar [jar包] generate -a -l -o
- 脚本
  ```
  #!/bin/bash 
  java -jar target/jxy-generator-basic-1.0-SNAPSHOT-jar-with-dependencies.jar "$@"
  ```
  
#### 制作工具开发

首先，定要理清楚生成器制作工具、代码生成器和目标代码的关系，如下图：
![img_2.png](img%2Fimg_2.png)
完整业务流程图如下:
![img_3.png](img%2Fimg_3.png)

##### 元信息
* 为什么需要元信息文件呢? 本质上是把在项目中硬编码的内容转为可以灵活替换的配置。
* 这里我们使用**JSON**格式存储元信息。
* 常见的一些JSON 文件转 Java 类代码的 IDEA 插件 ：
  * GsonFormatPlus 
  * oboPOJOGenerator 
  * Json2Pojo
* 例子
```json
{
  "name": "acm-template-pro-generator",
  "description": "ACM 示例模板生成器",
  "basePackage": "com.jxy",
  "version": "1.0",
  "author": "jxy",
  "createTime": "2023-12-4",
  "fileConfig": {
    "inputRootPath": "D:/code/project/generator/jxy-generator/jxy-generator-demo/acm-template-pro",
    "outputRootPath": "generated",
    "type": "dir",
    "files":[
      {
        "inputPath": "src/com/jxy/acm/MainTemplate.java.ftl",
        "outputPath": "src/com/jxy/acm/MainTemplate.java",
        "type": "file",
        "generateType": "dynamic"
      },
      {
        "inputPath": ".gitignore",
        "outputPath": ".gitignore",
        "type": "file",
        "generateType": "static"
      },
      {
        "inputPath": "README.md",
        "outputPath": "README.md",
        "type": "file",
        "generateType": "static"
      }
    ]
  },
  "modelConfig": {
    "models": [
      {
        "fieldName": "loop",
        "type": "boolean",
        "description": "是否循环",
        "defaultValue": "false",
        "abbr": "l"
      },
      {
        "fieldName": "author",
        "type": "String",
        "description": "作者",
        "defaultValue": "jxy",
        "abbr": "a"
      },
      {
        "fieldName": "outputText",
        "type": "String",
        "description": "输出信息",
        "defaultValue": "sum = ",
        "abbr": "o"
      }
    ]
  }
}
```

##### 开发步骤
开发顺序遵循上面需求分析中提到的代码生成器制作步骤，分为
1. 项目初始化 
2. 读取元信息 
3. 生成数据模型文件 
4. 生成 Picocli 命令类 
5. 生成代码生成文件
6. 程序构建jar 包 
7. 程序封装脚本 
8. 测试验证


#### 制作工具优化

##### 可移植性优化
在之前的代码实现中，模板文件的路径是绝对路径，此时改变运行环境就会出现问题，**可移植性差**，此时将绝对路径改为相对路径就解决了该问题。
具体步骤：
1. meta.json中新增一个 **sourceRootPath** 代替原本的 inputRootPath
2. inputRootPath 替换为 .source/ + sourceRootPath的最后一级目录
3. 复制模板文件到 inputRootPath 下
##### 功能优化
1. 增加项目于介绍文件
2. 制作精简版代码生成器
3. 支持Git托管项目
##### 健壮性优化
1. 该项目的重点是代码生成，而代码又是基于**元信息**生成的，因此**元信息校验和默认值填充**对于该项目的健壮性至关重要。
2. 自定义异常类
3. 编写校验类
4. 圈复杂度优化
   * 在IDEA 中，可以通过 **MetricsReloaded** 插件来检测代码圈复杂度
##### 可扩展性优化
1. 枚举类定义
   * 文件类型枚举：dir、file
   * 文件生成类型枚举：dynamic、static
   * 模板类型枚举：字符串、布尔
2. 模板方法模式
   * 使用模板方法模式可以实现更加细致化的用户定制，如：是否生成精简版代码、是否开启Git托管。


#### 配置能力增强

##### Spring Boot 项目模板介绍
模板拥有的能力如下
1. 实现了用户登录、注册、注销、更新、检索、权限管理口
2. 帖子创建、删除、编辑、更新、数据库检索、ES 灵活检索
3. 使用了 MySQL、Redis、Elasticsearch 数据存储
4. 使用 Swagger + Knife4j口 实现接口文档生成 
5. 支持全局跨域处理

##### 生成器应具备的功能
基于模板具有的基本能力，我们可以分析用户可能会有哪些定制化的代码生成需求，并明确代码生成器应该具备的功能.
比如:
1. 替换生成的代码包名 
2. 控制是否生成帖子相关功能 
3. 控制是否需要开启跨域 
4. 自定义 Knife4jConfig 接口文档配置 
5. 自定义 MySQL 配置信息 
6. 控制是否开启 Redis 
7. 控制是否开启 Elasticsearch

##### 实现思路
以上 Spring Boot 模板项目只是一个例子，我们的目标是通过这个示例，从特定需求中抽象出制作工具应具备的通用能力。
让我们依次分析上述功能的 **实现思路**，并挖掘出 **通用能力**

##### 依次分析
1. 需求: 替换生成的代码包名
* 实现思路: 和之前替换包名的实现方式类似，可以将代码中所有出现包名的地方 “挖坑”指定类似 basePackage 的模型参数，让用户自己输入
* 通用能力:由于用到包名的代码非常多，如果都要自己“挖坑” 并制作 FTL 动态模板，不仅成本高、而且也容易出现遗漏 (比如如 @MapperScan 注解里也有包名)。所以我们需要利用制作工具来自动 “挖坑” 并生成模板文件
2. 需求: 控制是否生成帖子相关功能实现思路: 允许用户输入一个开关参数来控制帖子功能相关的文件是否生成，比如PostController、PostService、 PostMapper、 PostMapperxml、Post 实体类等通用能力:用一个参数同时控制多个文件是否生成，而不是仅仅是某段代码是否生成
3. 需求: 控制是否需要开启跨域
* 实现思路: 允许用户输入一个开关参数来控制跨域相关的文件是否生成，比如CorsConfig口.java 文件
* 通用能力:用一个参数控制某个文件是否生成，而不是仅能控制代码是否生成
4. 需求: 自定义 Knife4jConfig 接口文档配置实现思路: 修改 Knife4iConfig 文件中的配置，比如 title、description、version、apis 扫描包路径等。
* 通用能力: 由于要支持用户输入的参数较多，可以用一个参数控制是否要开启接口文档配置如果开启，再让用户输入 一组 配置参数
5. 需求: 自定义 MySQL 配置信息
* 实现思路: 修改 application.yml 配置文件中 MySQL的 url、username、 password 参数.通用能力: 由于要支持用户输入的参数较多，可以定义一组隔离的配置参数
6. 需求: 控制是否开启 Redis
* 实现思路: 修改和开启 Redis 相关的代码，比如 application.yml、pom.xml.MainApplicationjava 等多人文件的部分代码通用能力: 用一个参数同时控制多个文件的代码修改 (已满足)
7. 需求: 控制是否开启 Elasticsearch
* 实现思路:
   * 修改和 Elasticsearch 相关的代码，比如 PostController、 PostServicePostServicelmpl、application.yml 等多个文件的部分代码
   * 用参数控制 PostEsDTO 整个文件是否生成
* 通用能力: 用一个参数同时控制多个文件的代码、以及某文件是否生成


##### 实现流程
通过上面的分析，我们会发现每个功能的实现所需要的通用能力各不相同，那我们应该先做什么、后做什么、怎么安排实现流程最合理呢?

这里我们一定要综合考虑所有的需求，顾全大局;并且通过需求间的依赖关系、或者实现难易度去综合排序，一步步实现。

现在的制作工具已经具有的能力是:根据某个模型参数同时控制多处代码的修改而根据排序，制作工具需要增强的能力有:
1. 一个模型参数对应某个文件是否生成 
2. 一个模型参数对应多个文件是否生成 
3. 一个模型参数同时控制多处代码修改以及文件是否生成 
4. 定义一组相关的模型参数，控制代码修改或文件生成 
5. 定义一组相关的模型参数，并能够通过其他的模型参数控制是否需要输入该组参数



#### 模板制作工具

##### 重点内容
1. 模板制作工具- 需求分析 
2. 模板制作工具 - 核心设计 
3. 模板制作工具 - 基础功能实现
4. 模板制作工具- 更多功能实现

##### 需求分析
还记得么?在上一个版本的代码中，我们遇到了一个问题:当我们更改元信息数据模型配置，将模型参数进行分组后，我们之前已经编写的 FreeMarker 动态模板就无法正确生成内容了。这是因为使用的模型参数发生了变更，导致无法正确获得值.

通过这个问题，我们会发现，动态模板和元信息配置是有很强的绑定关系的，稍有不慎，就有可能导致代码生成异常。

此外，还遗留了一个需求无法解决 ---- 替换生成的代码包名。

因为对于 Spring Boot 项目模板这种相对复杂的项目，里面用到包名的 Java 文件太多了，如果每个文件都要自己“挖坑”来制作模板，不仅成本高、也容易出现遗漏。

也就是说，虽然制作工具已经能够生成代码生成器了，但还是存在 2 大问题：
1. 需要人工提前准备动态模板，项目文件越多，使用成本越高
2. 需要根据动态模板编写对应的配置，参数越多，越容易出现和模板不一致的风险

如何解决这个问题呢?
答案很简单。我们可以让制作工具根据我们的想法，自动给项目文件“挖坑”，并生成相互对应的动态模板文件和元信息配置。提高效率的同时，减少模型参数和模板不一致的风险

不过需要明确一点: **制作工具的作用只是提高效率，无法覆盖所有的定制需求!**

因为想要如何制作代码生成器，还是取决于开发者。

##### 核心设计

在使用制作工具生成前，我们依次做了以下事情:
1. 先指定一个原始的、待“挖坑”的输入文件
2. 明确文件中需要被动态替换的内容和模型参数
3. 自己编写 FreeMarker FTL 模板文件 
4. 自己编写生成器的元信息配置，包括基本信息、文件配置、模型参数配置

由此，我们可以分析出快速制作模板的 **基本公式** ：
* 向制作工具输入: 基本信息 + 输入文件 + 型参数 (+ 输出规则)
* 由制作工具输出: 模板文件 + 元信息配置

对应的算法流程如下：
![img_4.png](img%2Fimg_4.png)


##### 基础功能实现

###### 基本流程实现

实现步骤如下：
1. 提供输入参数:包括生成器基本信息、原始项目目录、原始文件、模型参数
2. 基于字符串替换算法，使用模型参数的字段名称来替换原始文件的指定内容，并使用替换后的内容来创建 FTL 动态模板文件 
3. 使用输入信息来创建 ``meta.json`` 元信息文件

###### 工作空间隔离
虽然制作模板的流程是跑通了，但我们会发现一个问题: 上述代码直接在原始项目内生成了模板和元信息配置，其实是对原项目的污染。如果我们想重新生成，就得一个个删除上次生成的文件。

想解决上面的问题，其实很简单。每次制作模板时，我们都不直接修改原始项目的任何文件而是先复制原项目到一个临时的、专门用于制作模板的目录，然后在该目录下完成文件的生和处理。

可以将上述临时目录称为 ``工作空间``，每次模板制作应该属于不同的工作空间，互不影响.

我们约定将 ``maker`` 项目下 ``.temp`` 临时目录作为工作空间的根目录，并且在项目的 ``.gitignore`` 文件中忽略该目录。

在 ``TemplateMaker`` 原有代码的基础上新增复制目录的逻辑"
1. 需要用户传入 ``originProjectPath`` 变量代表原始项目路径 
2. 每次制作分配一个唯一id (使用雪花算法)，作为工作空间的名称，从而实现隔离 
3. 通过 ``FileUtil.copy`` 复制目录 
4. 修改变量 ``sourceRootPath`` 的值为复制后的工作空间内的项目根目录


###### 分步制作能力

般来说，我们在制作模板时，不可能只 “挖一个坑”，只允许用户自定义输入一个参数；
也不可能一次性 “挖完所有坑”。而是一步一步地替换参数、制作模板。

所以，我们的制作工具要有分步制作、追加配置的能力，具体要做到以下 3 点 
1. 输入过一次的信息，不用重复输入，比如基本的项目信息
2. 后续制作时，不用再次复制原始项目，而是可以在原有文件的基础上，多次追加或覆盖新的文件
3. 后续制作时，可以在原有配置的基础上，多次追加或覆盖配置

想要实现这个能力，我们首先要让制作工具 “**有状态**”

**有状态和无状态**

什么是有状态?

是指程序或请求多次执行时，下一次执行保留对上一次执行的记忆。比如用户登录后服务器会记住用户的信息，下一次请求就能正常使用系统。

与之相对的是**无状态**。是指每次程序或请求执行，都像是第一次执行一样，没有任何历史信息。很多 Restful API 会采用无状态的设计，能够节省服务器的资源占用


**有状态实现**

想实现有状态，往往需要 2 个要素: **唯一标识和存储**

其实在上一步“工作空间隔离” 中，我们已经给每个工作空间分配了一个唯一的 id 作为标识;并且将 id 作为工作空间的目录名称，相当于使用本地文件系统作为了 id 的存储

那么我们只要在第一次制作时，生成唯一的 id;然后在后续制作时，使用相同的 id，就能找到之前的工作空间目录，从而追加文件或配置


**多次制作实现**

如果根据 id 判断出并非首次制作，我们又应该做哪些调整呢? 应该如何加配置和文件呢?

这里我考虑到 3 点： 
1. 非首次制作，不需要复制原始项目文件
2. 非首次制作，可以在已有模板的基础上再次挖坑
3. 非首次制作，不需要重复输入已有元信息，而是在此基础上覆盖和追加元信息配置


##### 更多功能实现

###### 单次制作多个模板文件

虽然现在模板制作工具可以通过多次执行来制作多个模板文件，但还是比较麻烦。对于我们之前提到的 “批量替换项目下所有文件包名” 的需求，可能需要制作几十个模板文件，难道要执行几十次么?

所以我们需要实现多模板文件同时制作的能力有 2 种方法：

1. 支持输入文件目录，同时处理该目录下的所有文件 
2. 支持输入多个文件路径，同时处理这些文件



###### 文件过滤

回忆下我们之前梳理的 Spring Boot 模板生成器需要的一个功能

> 需求: 控制是否生成帖子相关功能
> 
> 实现思路: 允许用户输入一个开关参数来控制帖子功能相关的文件是否生成，比如PostController、PostService、PostMapper、PostMapper.xml、Post 实体类等
> 
> 通用能力:某个范围下的多个指定文件挖坑=>绑定同个参数

为了实现这个需求，我们要同时对多个名称包含 Post 的文件进行处理。由于这些文件分散在不同的目录中，我们没有办法通过直接指定一个目录完成制作。单次制作时输入多个文件是可行的提效方式，但如果文件数量再多一些，依次去写文件的路径也会成为一种麻烦。

有没有更优雅的方式呢?

答案是肯定的，想想我们平时查找文件时会怎么办?肯定是输入一些关键词来过滤文件对吧没错，我们可以给模板制作工具增加 **文件过滤** 功能，通过多种不同的过滤方式帮助用户选择文件，更灵活地完成批量模板制作。


**文件过滤机制设计**

文件过滤可以有很多种不同的配置方式，归纳了 2 类配置
* **过滤范围**: 根据文件名称、或者文件内容过滤
* **过滤规则**: 包含 contains、前缀匹配 startsWith、后缀匹配 endsWith、正则 regex.
相等 equals。


由于制作工具已经支持输入多个文件/目录，所以其实每个文件/目录都可以指定自己的过滤规则，而且能同时指定多条过滤规则 (必须同时满足才保留)，进一步提高灵活性。



###### 文件分组

目前，我们的制作工具已经支持对文件进行分组，并且通过给组设置 condition 的方式，支持用单个模型参数同时控制一组文件。

同样的，我们的模板制作工具也需要拥有快速生成文件组配置的能力。


**实现思路**

怎么实现呢?

我们现在已经能够单次制作多个文件了，而且根据用户习惯，同一次制作的多个文件更有可能属于同一组。那么其实我们不用让用户再手动配置如何分组了，可以自动分组。

有 2 种分组策略:
1. 一个文件信息配置 (FilelnfoConfigDD) 对应一次分组。如果传入的 path 是目录，则目录下的所有文件为同组
2. 一个完整的文件配置 (TemplateMakerFileConfigD) 对应一次分组。即配置 files 列表中的所有文件都属于同组。

这里选择第 2 种方案。原因是从需求出发，对于 “要用一个参数控制帖子相关的文件是否生成” 的需求，有可能要把跨目录下的文件设置为一个组。第 2 种方案会更灵活。


###### 模型分组

和文件分组一样，之前我们的制作工具已经实现了模型分组的能力。那现在我们的模板制作工具也需要能够同时指定多个模型参数进行“挖坑”，并生成模型分组配置。

**实现思路**

模型分组的实现思路和文件分组逻辑几乎一致，此处不再赘述。但有一点需要注意，之前我们在测试模板制作工具时，传入的都是单个模型参数和要替换的字符串参数 (searchStr)。但现在如果要一次性输入多个模型参数，也要传入多个要替换的字符串。准确地说，每个模型和要替换的字符串参数应该一一对应。所以我们需要用额外的类来封装这些参数。

##### bug修复

###### bug1 同配置多次生成，强制变为静态生成

如果两次制作模板时，配置文件中使用了同一个文件(比如 ``application.yml``)、以及相同的模型，那么第二次制作时会判断替换后的模板内容和第一次相同 (因为第一次已经替换过了)，导致该文件被识别为了静态生成，得到了错误的配置文件

> testTemplateMakerBug1

###### bug2 错误处理了新生成的模板文件

如果多次制作时指定了相同的目录 (如 ``common`` 包)，那么后续制作时会扫描到之前生成的 ``FTL`` 模板文件，并尝试基于 ``FTL`` 文件再次制作模板，导致生成了错误的配置

> testTemplateMakerBug2

###### bug3 模板制作工具生成的配置文件中 文件输入路径与输出路径相反

在制作模板时，我们是根据原始文件得到 ``FTL`` 模板文件，但是在代码生成器的元信息中，其实是根据 ``FTL`` 模板文件来生成目标文件。

> testTemplateMakerBug3

###### bug4 调整配置文件生成路径

现在我们的 ``meta.json`` 文件会生成在工作空间内、项目的根目录下，如果我们指定的输入文件路径是项目的根目录，那么 ``meta.json`` 文件也会被当成项目文件被扫描处理.

> testTemplateMakerBug4


##### 参数封装 - 易用性优化
之前每次使用制作工具时，我们都要自主编写和封装冬种配置对象，非常麻烦。

有没有更简单的方式呢?

我们可以把所有模板制作工具需要的参数统一封装为一个对象，这样就可以通过传递一个JSON 配置文件 (或者后续的 HTTP Post 请求) 来快速填充参数。

