# 性能优化

## 一、性能优化思路

首先明确性能优化的定义和目标。性能优化是指通过 **持续的** 分析、实践和测试，确保系统稳定高效运行，从而满足用户的诉求。

性能优化闭环:
![img_6.png](img%2Fimg_6.png)

### 性能优化分类

一般情况下，我们把性能优化分为2大类:

1. 通用优化

    是指一些经典的、对于绝大多数情况都适用的优化策略。比如增大服务器的并发请求处理数使用缓存减少数据库查询、通过负载均衡分摊请求、同步转异步等。
2. 对症下药

    是指结合具体的业务特性和系统现状，先通过性能监控工具、压力测试等方式，分析出系统的性能瓶颈，再针对性地选取策略进行优化。比如数据库单次查询超过1秒，属于慢查询，根据实际的查询条件给对应的字段增加索引
般就能提高查询性能。

实际开发中，这两类性能优化策略通常都要使用。在系统设计和开发阶段，我们要根据自己的需要迭代优化的概率。此经验，本能地引入一些性能优化的手段，降低后续系统出现问题、需要迭代优化的概率。此外，性能优化一定是持续的，随着需求、用户、系统用量的增多，原本性能符合要求的系统也可能会出现各种新的问题，很难面面俱到、一步到位。

但是，对于复杂的、对可用性和稳定性要求极高的项目，我们可以提前通过压力测试来模拟用户量极大的情况，并提前做好性能优化和应对措施。

### 通用优化手段

有哪些通用的性能优化手段呢?

我们以一个请求的完整生命周期为例，依次去介绍。

通常，用户从发送请求，到最终得到数据，要分别经过以下节点:

![img_7.png](img%2Fimg_7.png)

每个节点，我们都有对应的优化方法:

1. 前端:
   * 离线缓存: 利用浏览器的缓存机制，请求过一次的资源就不用重复请求，提高页面加载速度。
   * 请求合并: 页面请求过多时，将多个小请求合并成一个大请求，减少网络开销。
   * 懒加载: 延迟加载页面的图片等元素，提高首屏加载速度。

2. 网关:
   * 负载均衡: 负责接受请求，根据一定的路由算法转发到对应的后端系统，实现多个后端服务器分摊请求，增大并发量。
   * 缓存: 将后端返回的数据进行缓存，下次前端请求时，直接从网关获取数据，减少后端调用、提高数据获取速度。
3. 后端请求层:
   * 服务器优化: 根据业务特性，选择性能更高的服务器并调整参数，比如 Nginx、Undertow 等。
   * 微服务: 将大型服务拆分为小型服务，并通过微服务网关进行转发，增大各服务的并发处理能力。
4. 业务逻辑层:
   * 异步化: 将同步的业务逻辑改为异步，尽早响应，提高并发处理能力。
   * 多线程: 将复杂的操作拆分成多个任务，通过多线程并发执行，提高任务处理效率。
5. 中间件(第三方依赖)
   * 缓存: 将数据库查询出的结果数据缓存到性能更高的服务(比如基于内存的 Redis 或本地)，减少数据库的压力、并提高数据查询性能。
   * 队列: 使用消息队列，对系统进行解耦、或者将操作异步化，实现流量的削峰填谷。
6. 存储层:
   * 分库分表: 数据量极大时，对数据库进行垂直或水平切分，提高数据库并发处理能力数据清理:定期清理无用或过期的数据，减少存储压力，必要时可以对数据进行备份转储。

虽然有那么多性能优化方法，但并不是每一种都要用、每一种都有用。在做性能优化时，一定要根据实际情况，权衡性价比和系统改动风险，并且做好充分的测试，不要好心优化、结果给系统导入了新的 Bug。而且一般情况下，不建议大家为了优化盲目引入新技术，先从成本最低的优化方法开始。

举个例子，你在本地使用 **Elasticsearch** 优化了查询性能，但是公司根本没有成本采购Elasticsearch，这就脱离了实际情况
大家先了解这些方法，日后做性能优化时能够想起来就足够了。

## 二、核心功能性能优化

### 下载生成器接口
1. 下载优化 - 遵循最佳实践

    [官网](https://cloud.tencent.com/document/product/436/13653)
2. 下载优化 - 流式处理

   下载大文件时，除了下载慢之外，还可能会占用服务器的内存、硬盘空间，导致资源紧张。
   
   所以，如果文件较大、并且服务端不用处理文件，可以选用流式处理，通过循环的方式，持续从 **cosObiectInputstream** 读取数据并写进响应输出流，防止过大的文件占满内存。

   示例代码如下：
   ```java
   response.setContentType("application/octet-stream;charset=UTF-8");
   response.setHeader("Content-Disposition", "attachment; filename=" + filepath);
   
   // 将 InputStream 写入到 HttpServletResponse 的 OutputStream
     try(OutputStream out = response.getOutputStream()) {
         byte[] buffer = new byte[4096];
         int bytesRead;
   
         while ((bytesRead = cosObjectInput.read(buffer)) != -1) {
             out.write(buffer, 0, bytesRead);
         }
     } catch (Exception e) {
         e.printStackTrace();
     }
   ```

   在前端进行测试，发现采用这种方式后，下载文件时响应内容的大小会逐渐递增，而不是阻塞半天后一次性得到完整的响应结果。

   但是经过测试发现，大文件整体的下载时间并没有得到明显的减少。因为无论是否流失处理服务器都要先从 COS 对象存储下载文件，再返回给前端。

   那么如果要优化，是否可以不从对象存储下载文件呢?

3. 下载优化 - 本地缓存

   答案是肯定的。代码生成器文件的业务特点是 **读多写少**，是一个典型的缓存适用场景。

   其实 CDN 本质上就是一种缓存，如果不想使用 CDN 增加开销的话，可以选用本地缓存。不需要引入额外的存储技术，只需要将下载过一次的代码生成器保存在服务器上，之后要下载时，如果服务器已经有下载好的文件，就不用从对象存储获取，直接读取并返回给前端即可。

   缓存的 4 个核心要素:
   1. 缓存哪些内容
   2. 缓存如何淘汰
   3. 缓存 **key** 如何设计
   4. 如何保证缓存一致性

> 热点key实践：[https://gitee.com/jd-platform-opensource/hotkey](热点key实践)

### 使用生成器接口

1. **下载压缩包**耗时较多，优化前面已经实现，可将两者进行合并。
2. **执行脚本**耗时也较多，但由于调用 **maker** 项目实现好的方法，优化成本较高。

### 制作生成器接口

先优化下载耗时。分析下载流程，先让用户将模板文件上传到对象存储、再从对象存储下载的过程其实是没必要的。因为平台现在仅支持单次制作，制作完成后，用户上传的板文件就没用了。所以不如直接通过请求参数传递原始文件给后端，既节约了对象存储资源、又提升了性能。

虽然制作操作耗时比下载耗时更多，但其实 2-3 秒是可以接受的范围，而且由于调用了maker 项目、使用 Maven 进行打包，优化的成本较大，此处暂不考虑。(应该也是需要多线程并发)

如果制作耗时超过 20 秒，可以考虑使用 **异步化**，将生成器制作封装为一个任务，用户可以通过前端页面自主查询任务的执行状态并下载制作结果。


## 三、查询性能优化

### 方法一：精简数据

如何减少前端下载内容的时间呢?

很简单，2 种方法:

1. 减少后端返回的数据体积，可以减少返回的数据、或者压缩数据
2. 提高服务器的带宽

显然，第一种方法的成本是最低的，所以我们可以尝试精简数据，只让后端返回主页需要展示的数据。像文件配置(fileConfig)模型配置(modelConfig)都不是必要的。

优化前：
![img_8.png](img%2Fimg_8.png)

优化后：
![img_9.png](img%2Fimg_9.png)

经对比，优化了 **五分之一** 的效率。

### 方法二：SQL 优化

**策略**：删掉不需要返回的字段信息。 

初始时的 SQL 语句为：
```sql
SELECT id,name,description,basePackage,version,author,tags,picture,status,userId,createTime,updateTime FROM generator WHERE isDelete=0 ORDER BY createTime DESC LIMIT 4;
```

优化之后的 SQL 语句为：
```sql
SELECT id,name,description,basePackage,version,author,tags,picture,fileConfig,modelConfig,distPath,status,userId,createTime,updateTime,isDelete FROM generator WHERE isDelete=0 ORDER BY createTime DESC LIMIT 4;
```

SQL 控制台的查询时间分别如下：

优化前：
![img_10.png](img%2Fimg_10.png)

优化后：
![img_11.png](img%2Fimg_11.png)

优化 SQL 之后，整整快了 **1秒** 的时间。

### 方法三：分布式缓存

使用 **Redis** 中的 **StringRedisTemplate** 进行分布式缓存

初始时的压测结果：
![img_13.png](img%2Fimg_13.png)

使用缓存之后的压测结果：
![img_14.png](img%2Fimg_14.png)

吞吐量整整增加了 **10倍** 左右！

### 方法四：多级缓存

多级缓存设计：

对于分布式系统，我们一般不会单独使用本地缓存，而是将本地缓存和分布式缓存进行组合，形成多级缓存。

就以 **Caffeine** 和 **Redis** 为例，通常用 **Caffeine** 作为一级缓存，**Redis** 作为二级缓存。

1. Caffeine 一级缓存:将数据存储在应用程序的内存中，性能更高。但是仅在本地生效，而且应用程序关闭后，数据会丢失。
2. Redis 二级缓存:将数据存储在 Redis 中，所有的程序都从 Redis 内读取数据，可以实现数据的持久化和缓存的共享。

二者结合，请求数据时，首先查找本地一级缓存;如果在本地缓存中没有查询到数据，再查找远程二级缓存，并且写入到本地缓存;如果还没有数据，才从数据库中读取，并且写入到所有缓存。

使用多级缓存，可以充分利用本地缓存的快速读取特性，以及远程缓存的共享和持久化特性。

优化结果如下：

![img_15.png](img%2Fimg_15.png)

咦，为什么性能没有明显的提升呢?

几个猜测:
1. 由于 Redis 也在本地，所以性能提升并不明显。
2. 直接读取本地已经是最快的读取方法了，也许系统存在其他的性能瓶颈?

### 方法五：计算优化

任何计算都会消耗系统的 CPU 资源，在 CPU 资源有限的情况下，我们能做的就是 **减少不必要的计算**。

分析我们的代码，基本上没有循环计算逻辑，可能消耗计算资源的操作应该就是 JSON 序列化(反序列化)。

> 在 JSON 序列化中，需要遍历数据结构并将其转换为 JSON 格式的字符串。这个过程中可能在 JSON 序列化中，涉及到字符串拼接、字符编码转换等计算密集型操作。

之前是为了更直观地查看缓存数据，才将对象序列化为 JSON 后写入缓存，现在为了提高性能，我们可以直接用 JDK 默认的序列化工具读写缓存。

优化结果：
![img_16.png](img%2Fimg_16.png)

整整再优化了 **3倍**！

### 方法六：tomcat 参数优化

**Spring Boot** 项目默认使用嵌入式的 **Tomcat** 服务器接受处理请求，可以调整 tomcat的参数，比如最大线程数 maxThreads、最大连接数 maxConnections、请求队列长度accept-count 等，来增加同时接受处理请求的能力。

优化参数如下：
```yaml
server:
  tomcat:
    # 服务器在任何给定时间接受和处理的最大连接数。一旦达到限制，操作系统仍然可以接受基于“acceptCount”属性的连接。
    max-connections: 10000
    threads:
      # 工作线程的最大数量 io密集型建议10倍的cpu数，cpu密集型建议cpu数+1，绝大部分应用都是io密集型
      max: 5000
    # 当所有可能的请求处理线程都在使用中时，传入连接请求的最大队列长度
    accept-count: 1000
```

优化结果：
![img_17.png](img%2Fimg_17.png)

再优化了接近 **一倍** 的效率。

### 方法七：Vert.x 框架方面的优化

使用 **Vert.x** 代替 **Tomcat** 框架，实现 **后端请求层** 层次的优化。
[Vert.x官网](https://vertx.io/)

优化结果为：
![img_18.png](img%2Fimg_18.png)

再次优化了 **三分之一**。


## 性能优化总结

在**每秒 1000 个线程数**的前提下，吞吐量从最初的 **20** 优化到了 **980**，整整优化了 **49** 倍。
